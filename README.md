# DebugLogger

![PlatformIO](https://img.shields.io/badge/PlatformIO-Compatible-orange.svg)
![License](https://img.shields.io/badge/License-GPL--3.0-blue.svg)

## Описание

**DebugLogger** - это легковесная, удобная и эффективная библиотека, предназначенная для отладочного вывода в последовательный порт на платформах, совместимых с Arduino. Она реализует интуитивно понятный синтаксис, схожий с `std::cout` в C++, путем перегрузки оператора `<<`.
Библиотека в сущности является просто "оберткой" для стандартного `Serial.print`, но добавляет гибкость в форматировании и отключении всей отладки с помощью всего одного макроса. Поэтому потребление памяти у нее минимально.

### Ключевые особенности

- **Простой синтаксис:** Используйте `Debug << "Value of Pin A0: " << myVariable << endl;`.  
- **Поддержка различных типов данных:** `const char*`, `char`, `int`, `unsigned int`, `long`, `unsigned long`, `double`, `String`.  
- **Манипуляторы форматирования:** Включает удобные манипуляторы для вывода чисел в различных форматах: `hex` (шестнадцатеричный), `dec` (десятичный), `oct` (восьмеричный) и `bin` (двоичный).  
- **Поддержка printf:** Предоставляет функциональность `printf` для платформ **ESP32**, **ESP8266** и ядер [**MCUdude**](https://github.com/MCUdude), автоматически определяя их наличие.  
- **Оптимизация компиляции:** Весь отладочный код может быть полностью отключен на этапе компиляции с помощью макроса `#define DEBUG 0`, что значительно минимизирует размер прошивки и не влияет на производительность в релизных сборках.  
- **Совместимость:** Совместима с Arduino IDE и PlatformIO.

## Сравнение потребления ресурсов: Serial.print vs. DebugLogger

При разработке приложений для микроконтроллеров важно учитывать потребление памяти и ресурсов. Выбор инструмента для отладки может существенно повлиять на итоговые характеристики вашего проекта. Рассмотрим два подхода: использование стандартного `Serial.print` и библиотеки **DebugLogger**.

### **Отключение отладки (DEBUG 0)**

Когда отладка отключена (Serial.print закомментирован вручную) потребление памяти одинаково минимально у обоих методов. Если же Serial.print не комментировать вручную, то:

- `Serial.print`: - весь отладочный код будет включен в скомпилированную программу. Это приведет к тому, что потребление памяти останется высоким, практически таким же, как и в режиме отладки.
- **DebugLogger**: - автоматически исключает отладочный код из компиляции, если отладка выключена. В результате потребление памяти становится минимальным, что позволяет освободить ресурсы для основной логики вашего приложения. Это одно из ключевых преимущество **DebugLogger**, так как вам не нужно вручную редактировать код.

### Включение отладки (DEBUG 1)

При включенной отладке **DebugLogger** демонстрирует небольшое увеличение потребления ресурсов по сравнению с `Serial.print`, но это компенсируется удобством:

- **На обычных ядрах (без нативной поддержки `printf`):**  
  - **DebugLogger:** Потребляет приблизительно на 4 байта больше ОЗУ и на 104 байта больше Flash по сравнению с `Serial.print`.  
  - **Serial.print:** Позволяет сэкономить небольшой объем памяти, но требует трудоемкого ручного комментирования отладочных сообщений.  
- **На ядрах с поддержкой `printf` (ESP32/ESP8266, MCUdude):**  
  - **DebugLogger:** Потребляет всего на 2 байта больше ОЗУ и на 12 байт больше Flash. Эта разница минимальна и практически незаметна на практике.

Несмотря на незначительное увеличение потребления ресурсов в режиме отладки, главное преимущество **DebugLogger** — это **автоматизация и удобство использования**. Библиотека значительно ускоряет процесс разработки, избавляя вас от ручного комментирования и раскомментирования отладочных строк. Экономия времени и усилий при подготовке финальной версии прошивки с лихвой окупает незначительные затраты памяти.

***Примечание: замер производился в среде VSCode + PlatformIO. В Arduino IDE будут другие цифры.***

## Установка

Библиотека **DebugLogger** полностью совместима с Arduino IDE и PlatformIO.

### Arduino IDE

1. Скачайте архив библиотеки по [ссылке](https://github.com/ThinkerSan/DebugLogger).  
2. В Arduino IDE перейдите в **Скетч > Подключить библиотеку > Добавить .ZIP библиотеку....**  
3. Выберите скачанный архив.

### PlatformIO

Добавьте следующую строку в файл `platformio.ini` вашего проекта:

```ini
lib_deps =  
    ThinkerSan/DebugLogger@^1.0.0
```

## Использование

### 1. Подключение и инициализация

Включите `DebugLogger.h` в ваш код, определите макрос `DEBUG` (если необходимо) и инициализируйте последовательный порт в функции `setup()`.

```cpp
#include <Arduino.h>  
#include "DebugLogger.h" // Подключаем заголовочный файл библиотеки

// Определите этот макрос для включения отладочного вывода.  
// Для отключения отладки измените на #define DEBUG 0 или закомментируйте.  
#ifndef DEBUG
  #define DEBUG 1
#endif

void setup() {  
  // Инициализация последовательного порта со скоростью 9600 бод.  
  Debug.begin(9600);  
}

void loop() {  
  // Ваш основной код программы  
}
```

### 2. Примеры вывода

#### Простой вывод текста и чисел

Используйте оператор `<<` для последовательного вывода различных типов данных.

```cpp
void loop() {  
  int value = 42;
  double pi = 3.14;
  
  Debug << "The answer is " << value << endl;
  Debug << "The value of PI is " << pi << endl;
    
  delay(1000);
}
```

#### Использование манипуляторов форматирования

Манипуляторы `hex`, `oct` и `bin` применяются только к следующему за ними числовому значению. После вывода числового значения, формат автоматически сбрасывается к десятичному (`dec`).

| Манипулятор | Назначение                 |
|-------------|----------------------------|
| `endl`      | Перевод строки             |
| `hex`       | Шестнадцатеричный формат   |
| `dec`       | Десятичный формат (по ум.) |
| `oct`       | Восьмеричный формат        |
| `bin`       | Двоичный формат            |

```cpp
void loop() {  
  int myNumber = 255;  

  Debug << "Decimal: " << myNumber << endl; // Выведет 255
  Debug << "Hexadecimal: " << hex << myNumber << endl; // Выведет FF
  Debug << "Octal: " << oct << myNumber << endl; // Выведет 377
  Debug << "Binary: " << bin << myNumber << endl; // Выведет 11111111

  // Пример цепочки вызовов с изменением формата
  Debug << "Value: " << myNumber << " (hex: " << hex << myNumber << ")" << endl;  

  delay(1000);
}
```

#### Использование printf (на поддерживаемых платформах)

Функциональность `printf` доступна только на платформах с нативной поддержкой, таких как **ESP32**, **ESP8266** или ядра [**MCUdude**](https://github.com/MCUdude). На других платформах вызов `Debug.printf()` будет автоматически проигнорирован компилятором.

```cpp
void loop() {  
  static unsigned long loopcounter = 0; // Статический счетчик итераций

  Debug.printf("Loop counter: %lu\n", loopcounter++); // Форматированный вывод

  delay(1000); // Задержка 1 секунда  
}
```

#### Использование автоматического определения поддержки printf

Библиотека включает макросы для автоматического определения ядер с поддержкой `printf`. Вы можете использовать их в своем коде для условной компиляции:

```cpp
void loop()  
{  
  static unsigned long loopcounter = 0;

  #if PRINTF_HAS_ESP || PRINTF_HAS_MCUDUDE // Проверяем, есть ли поддержка printf  
  Debug.printf("Loop counter: %lu\n", loopcounter++);  
  #else  
  // Если printf не поддерживается, используем оператор <<  
  Debug << "Loop counter: " << loopcounter++ << endl;  
  #endif

  delay(1000);  
}
```

### 3. Хранение строк во Flash-памяти

Для экономии оперативной памяти (SRAM), которая часто ограничена на микроконтроллерах, используйте макрос `F()` для хранения строковых литералов во Flash-памяти (Program Memory):

```cpp
// чернез оператор <<
Debug << F("Iteration #") << counter << F(": Sensor value = ") << sensorValue << endl;
// для printf
Debug.printf(F("Iteration # %d: Sensor value = %d\n"), counter, sensorValue);
```

## Отключение отладочного вывода

Чтобы полностью отключить весь отладочный код, просто измените значение макроса `DEBUG` на `0` или не определяйте его вовсе.
Если используется Arduino IDE, то это проще всего сделать в файле библиотеки `DebugLogger.h`:

```cpp
// DebugLogger.h
#ifndef DEBUG
  #define DEBUG 0 // Изменить здесь
#endif
```

Если используется PlatformIO, то этот флаг лучше определять в `platformio.ini` используя опцию `build_flags`:

```ini
; platformio.ini
[env:uno]
platform = atmelavr
board = uno
framework = arduino
build_flags = -D DEBUG=0
```

После этого весь код для вывода отладочной информации будет проигнорирован компилятором, что не скажется на размере и производительности вашей финальной прошивки.

## Примеры

Все примеры использования библиотеки расположены в каталоге **`examples`**. В каталоге **`compare`**, есть примеры для сравнения работы библиотеки и стандартного вывода через `Serial.print`.
Так же в каталоге **`extra`** есть пример файла `platformio.ini` для настройки PlarformIO в VSCode.

## Лицензия

Этот проект распространяется под лицензией **GNU v3.0**. Подробности см. в файле [LICENSE](https://github.com/ThinkerSan/DebugLogger/blob/main/LICENSE).
